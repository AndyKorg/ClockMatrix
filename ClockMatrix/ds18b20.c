/*
 * Измерение температуры на датчиках ds18b20
 * Поскольку иногда происходит сбой чтения результатов измерения, то чтение производится от 2 до 3 раз.
 * Истиным принимается значение прочитанное два раза. Если 3 раза прочитаны разные значения, то чтение повторяется
 * ver 1.3
 */ 

#include "bits_macros.h"
#include "OneWare.h"
#include "ds18b20.h"
#include "sensors.h"
#include "EERTOS.h"

//------------- Команды DS18B20
#define DS18B20_START			0x44			//Начать измерение температуры
#define DS18B20_READ			0xbe			//Прочитать память
#define DS18B20_REPEAT_READ		500				//Период повторного чтения состояния датчика если шина 1-ware занята
#define DS18B20_ERRPEPEAT_READ	200				//Период повторного чтения для уточнения результатов

#define DS_REPEAT_0XFF			3				//Количество повторных попыток чтения температуры 0xff, для минимизации ошибок

void StartMeasureDS18(void);					//Начать измерение температуры
void ErrorEvent(void);							//Вызывается при ошибке на шине

/************************************************************************/
/* Результат измерения прочитан, помещаем в структуру сенсоров			*/
/************************************************************************/
void ReadMeasurementComplet(void){
	u08 mOk = 0,
		val = ((owRecivBuf[0]>>4) & 0xf) | ((owRecivBuf[1]<<4) & 0xf0);	//Берется только целая часть температуры. У ds18b20 значения имеют старших 4 бита младшего байта и младших 4 бита старшего байта
	static u08 i=0, m1, m2, PreFF = 0;

	switch (i){
		case 0:									//Первое измерение просто запоминаем
			m1 = val;
			break;
		case 1:
			if (m1 == val){						//Если первое измерение и второе совпадают, то это истинное значение
				mOk = 1;
			}
			m2 = val;							//Запоминаем второе измерение на всякий случай
			break;
		case 3:
			if ((m2 == val) || (m1 == val)){		//Совпадает с одним из предыдущих измерений, считаем истинным
				mOk = 1;
			}
			i = 0; m1=0; m2=0;					//Не совпадают ни с одним. Запускаем цикл заново
			break;
		default:
			break;
	}
	if (mOk){									//Было совпадение измерение прекращаем
		i = 0; m1 = 0; m2 = 0;
		if ((val != 0xff) || (PreFF > DS_REPEAT_0XFF)){		//Значение не похоже на ошибочное чтение или оно было подтверждено 3 раза
			PreFF = 0;
			struct sSensor Sens;				//Ввел сюда структуру, что бы было видно, что здесь работаем со статусом датчика
			Sens.State = 0;
			SensorSetInBus(Sens);				//Сенсор на шине обнаружен
			SetSensor(SENSOR_DS18B20, Sens.State, val);	//Записать в массив датчиков
			if ((ClockStatus == csSensorSet) && (SetStatus == ssSensWaite)){	//Если режим ожидания датчика, то сразу обновить экран
				Refresh();
				SetTimerTask(StartMeasureDS18, DS18B20_ERRPEPEAT_READ);	//В режиме тестирования повторение измерения произвоится часто
			}
			return;
		}
		PreFF++;
	}
	i++;										//Следующий шаг
	SetTimerTask(StartMeasureDS18, DS18B20_ERRPEPEAT_READ);		//Повторить чтение через нужный промежуток
}

/************************************************************************/
/* Прочитать результат измерения							            */
/************************************************************************/
void StartReadMeasurement(void){
	if owIsFree(){								//Шина свободна?
		owSendBuf[0] = ONE_WARE_SKIP_ROM;
		owSendBuf[1] = DS18B20_READ;
		owSendAndReciv();						//Запись и чтение
		owCompleted = ReadMeasurementComplet;
		owExchage();
	}
	else{
		SetTimerTask(StartReadMeasurement, DS18B20_REPEAT_READ);
	}
}

/************************************************************************/
/* Была передана команда начала измерения, ждем результата              */
/************************************************************************/
void WaitEndMeasure(void){
	SetTimerTask(StartReadMeasurement, DS18B20_REPEAT_READ);	//Прочитать результат измерения
}

/************************************************************************/
/* Запустить измерения                                                  */
/************************************************************************/
void StartMeasureDS18(void){
	if owIsFree(){								//Шина свободна?
		owSendBuf[0] = ONE_WARE_SKIP_ROM;
		owSendBuf[1] = DS18B20_START;
		owSendOnly();							//Только передача
		owCompleted = WaitEndMeasure;
		owError = ErrorEvent;
		owExchage();							//Запустить обмен на шине 1-Ware
	}
	else{										//Шина занята, повторить старт опроса
		SetTimerTask(StartMeasureDS18, DS18B20_REPEAT_READ);
	}
}

/************************************************************************/
/* Ошибка операции на шине                                              */
/************************************************************************/
void ErrorEvent(void){
	struct sSensor Sens;						//Ввел сюда структуру, что бы было видно, что здесь работаем со статусом датчика
	Sens.State = 0;
	SensorNoInBus(Sens);						//Сенсор на шине НЕ обнаружен
	SetSensor(SENSOR_DS18B20, Sens.State, 0);			//Запомнить полученный результат
	SetTimerTask(StartMeasureDS18, DS18B20_REPEAT_READ);					//При ошибке попытаться прочитать еще раз шину
	if ((ClockStatus == csSensorSet) && (SetStatus == ssSensWaite))	//Если режим ожидания датчика, то сразу обновить экран
		Refresh();
}
